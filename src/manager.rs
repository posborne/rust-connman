// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

#![allow(dead_code)]
use dbus as dbus;
use dbus::arg;
use dbus::tree;

pub trait NetConnmanManager {
    type Err;
    fn get_properties(&self) -> Result<::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>, Self::Err>;
    fn set_property(&self, name: &str, value: arg::Variant<Box<arg::RefArg>>) -> Result<(), Self::Err>;
    fn get_technologies(&self) -> Result<Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)>, Self::Err>;
    fn remove_provider(&self, provider: dbus::Path) -> Result<(), Self::Err>;
    fn get_services(&self) -> Result<Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)>, Self::Err>;
    fn get_peers(&self) -> Result<Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)>, Self::Err>;
    fn connect_provider(&self, provider: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<dbus::Path<'static>, Self::Err>;
    fn register_agent(&self, path: dbus::Path) -> Result<(), Self::Err>;
    fn unregister_agent(&self, path: dbus::Path) -> Result<(), Self::Err>;
    fn register_counter(&self, path: dbus::Path, accuracy: u32, period: u32) -> Result<(), Self::Err>;
    fn unregister_counter(&self, path: dbus::Path) -> Result<(), Self::Err>;
    fn create_session(&self, settings: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>, notifier: dbus::Path) -> Result<dbus::Path<'static>, Self::Err>;
    fn destroy_session(&self, session: dbus::Path) -> Result<(), Self::Err>;
    fn request_private_network(&self) -> Result<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>, dbus::OwnedFd), Self::Err>;
    fn release_private_network(&self, path: dbus::Path) -> Result<(), Self::Err>;
    fn register_peer_service(&self, specification: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>, master: bool) -> Result<(), Self::Err>;
    fn unregister_peer_service(&self, specification: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> NetConnmanManager for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn get_properties(&self) -> Result<::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>, Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"GetProperties".into(), |_| {
        }));
        try!(m.as_result());
        let mut i = m.iter_init();
        let properties: ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>> = try!(i.read());
        Ok(properties)
    }

    fn set_property(&self, name: &str, value: arg::Variant<Box<arg::RefArg>>) -> Result<(), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"SetProperty".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(name);
            i.append(value);
        }));
        try!(m.as_result());
        Ok(())
    }

    fn get_technologies(&self) -> Result<Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)>, Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"GetTechnologies".into(), |_| {
        }));
        try!(m.as_result());
        let mut i = m.iter_init();
        let technologies: Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)> = try!(i.read());
        Ok(technologies)
    }

    fn remove_provider(&self, provider: dbus::Path) -> Result<(), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"RemoveProvider".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(provider);
        }));
        try!(m.as_result());
        Ok(())
    }

    fn get_services(&self) -> Result<Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)>, Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"GetServices".into(), |_| {
        }));
        try!(m.as_result());
        let mut i = m.iter_init();
        let services: Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)> = try!(i.read());
        Ok(services)
    }

    fn get_peers(&self) -> Result<Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)>, Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"GetPeers".into(), |_| {
        }));
        try!(m.as_result());
        let mut i = m.iter_init();
        let peers: Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)> = try!(i.read());
        Ok(peers)
    }

    fn connect_provider(&self, provider: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"ConnectProvider".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(provider);
        }));
        try!(m.as_result());
        let mut i = m.iter_init();
        let path: dbus::Path<'static> = try!(i.read());
        Ok(path)
    }

    fn register_agent(&self, path: dbus::Path) -> Result<(), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"RegisterAgent".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(path);
        }));
        try!(m.as_result());
        Ok(())
    }

    fn unregister_agent(&self, path: dbus::Path) -> Result<(), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"UnregisterAgent".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(path);
        }));
        try!(m.as_result());
        Ok(())
    }

    fn register_counter(&self, path: dbus::Path, accuracy: u32, period: u32) -> Result<(), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"RegisterCounter".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(path);
            i.append(accuracy);
            i.append(period);
        }));
        try!(m.as_result());
        Ok(())
    }

    fn unregister_counter(&self, path: dbus::Path) -> Result<(), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"UnregisterCounter".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(path);
        }));
        try!(m.as_result());
        Ok(())
    }

    fn create_session(&self, settings: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>, notifier: dbus::Path) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"CreateSession".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(settings);
            i.append(notifier);
        }));
        try!(m.as_result());
        let mut i = m.iter_init();
        let session: dbus::Path<'static> = try!(i.read());
        Ok(session)
    }

    fn destroy_session(&self, session: dbus::Path) -> Result<(), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"DestroySession".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(session);
        }));
        try!(m.as_result());
        Ok(())
    }

    fn request_private_network(&self) -> Result<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>, dbus::OwnedFd), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"RequestPrivateNetwork".into(), |_| {
        }));
        try!(m.as_result());
        let mut i = m.iter_init();
        let path: dbus::Path<'static> = try!(i.read());
        let settings: ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>> = try!(i.read());
        let socket: dbus::OwnedFd = try!(i.read());
        Ok((path, settings, socket))
    }

    fn release_private_network(&self, path: dbus::Path) -> Result<(), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"ReleasePrivateNetwork".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(path);
        }));
        try!(m.as_result());
        Ok(())
    }

    fn register_peer_service(&self, specification: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>, master: bool) -> Result<(), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"RegisterPeerService".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(specification);
            i.append(master);
        }));
        try!(m.as_result());
        Ok(())
    }

    fn unregister_peer_service(&self, specification: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Manager".into(), &"UnregisterPeerService".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(specification);
        }));
        try!(m.as_result());
        Ok(())
    }
}

pub fn net_connman_manager_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: NetConnmanManager<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("net.connman.Manager", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let properties = try!(d.get_properties());
        let rm = minfo.msg.method_return();
        let rm = rm.append1(properties);
        Ok(vec!(rm))
    };
    let m = factory.method("GetProperties", Default::default(), h);
    let m = m.out_arg(("properties", "a{sv}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = try!(i.read());
        let value: arg::Variant<Box<arg::RefArg>> = try!(i.read());
        let d = fclone(minfo);
        try!(d.set_property(name, value));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SetProperty", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("value", "v"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let technologies = try!(d.get_technologies());
        let rm = minfo.msg.method_return();
        let rm = rm.append1(technologies);
        Ok(vec!(rm))
    };
    let m = factory.method("GetTechnologies", Default::default(), h);
    let m = m.out_arg(("technologies", "a(oa{sv})"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let provider: dbus::Path = try!(i.read());
        let d = fclone(minfo);
        try!(d.remove_provider(provider));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RemoveProvider", Default::default(), h);
    let m = m.in_arg(("provider", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let services = try!(d.get_services());
        let rm = minfo.msg.method_return();
        let rm = rm.append1(services);
        Ok(vec!(rm))
    };
    let m = factory.method("GetServices", Default::default(), h);
    let m = m.out_arg(("services", "a(oa{sv})"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let peers = try!(d.get_peers());
        let rm = minfo.msg.method_return();
        let rm = rm.append1(peers);
        Ok(vec!(rm))
    };
    let m = factory.method("GetPeers", Default::default(), h);
    let m = m.out_arg(("peers", "a(oa{sv})"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let provider: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = try!(i.read());
        let d = fclone(minfo);
        let path = try!(d.connect_provider(provider));
        let rm = minfo.msg.method_return();
        let rm = rm.append1(path);
        Ok(vec!(rm))
    };
    let m = factory.method("ConnectProvider", Default::default(), h);
    let m = m.in_arg(("provider", "a{sv}"));
    let m = m.out_arg(("path", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let path: dbus::Path = try!(i.read());
        let d = fclone(minfo);
        try!(d.register_agent(path));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RegisterAgent", Default::default(), h);
    let m = m.in_arg(("path", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let path: dbus::Path = try!(i.read());
        let d = fclone(minfo);
        try!(d.unregister_agent(path));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("UnregisterAgent", Default::default(), h);
    let m = m.in_arg(("path", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let path: dbus::Path = try!(i.read());
        let accuracy: u32 = try!(i.read());
        let period: u32 = try!(i.read());
        let d = fclone(minfo);
        try!(d.register_counter(path, accuracy, period));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RegisterCounter", Default::default(), h);
    let m = m.in_arg(("path", "o"));
    let m = m.in_arg(("accuracy", "u"));
    let m = m.in_arg(("period", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let path: dbus::Path = try!(i.read());
        let d = fclone(minfo);
        try!(d.unregister_counter(path));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("UnregisterCounter", Default::default(), h);
    let m = m.in_arg(("path", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let settings: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = try!(i.read());
        let notifier: dbus::Path = try!(i.read());
        let d = fclone(minfo);
        let session = try!(d.create_session(settings, notifier));
        let rm = minfo.msg.method_return();
        let rm = rm.append1(session);
        Ok(vec!(rm))
    };
    let m = factory.method("CreateSession", Default::default(), h);
    let m = m.in_arg(("settings", "a{sv}"));
    let m = m.in_arg(("notifier", "o"));
    let m = m.out_arg(("session", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let session: dbus::Path = try!(i.read());
        let d = fclone(minfo);
        try!(d.destroy_session(session));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("DestroySession", Default::default(), h);
    let m = m.in_arg(("session", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let (path, settings, socket) = try!(d.request_private_network());
        let rm = minfo.msg.method_return();
        let rm = rm.append1(path);
        let rm = rm.append1(settings);
        let rm = rm.append1(socket);
        Ok(vec!(rm))
    };
    let m = factory.method("RequestPrivateNetwork", Default::default(), h);
    let m = m.out_arg(("path", "o"));
    let m = m.out_arg(("settings", "a{sv}"));
    let m = m.out_arg(("socket", "h"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let path: dbus::Path = try!(i.read());
        let d = fclone(minfo);
        try!(d.release_private_network(path));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("ReleasePrivateNetwork", Default::default(), h);
    let m = m.in_arg(("path", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let specification: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = try!(i.read());
        let master: bool = try!(i.read());
        let d = fclone(minfo);
        try!(d.register_peer_service(specification, master));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RegisterPeerService", Default::default(), h);
    let m = m.in_arg(("specification", "a{sv}"));
    let m = m.in_arg(("master", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let specification: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = try!(i.read());
        let d = fclone(minfo);
        try!(d.unregister_peer_service(specification));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("UnregisterPeerService", Default::default(), h);
    let m = m.in_arg(("specification", "a{sv}"));
    let i = i.add_m(m);
    i
}

#[derive(Debug)]
pub struct NetConnmanManagerPropertyChanged {
    pub name: String,
    pub value: arg::Variant<Box<arg::RefArg>>,
}

#[derive(Debug)]
pub struct NetConnmanManagerTechnologyAdded {
    pub path: dbus::Path<'static>,
    pub properties: ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>,
}

#[derive(Debug)]
pub struct NetConnmanManagerTechnologyRemoved {
    pub path: dbus::Path<'static>,
}

#[derive(Debug)]
pub struct NetConnmanManagerServicesChanged {
    pub changed: Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)>,
    pub removed: Vec<dbus::Path<'static>>,
}

#[derive(Debug)]
pub struct NetConnmanManagerPeersChanged {
    pub changed: Vec<(dbus::Path<'static>, ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>)>,
    pub removed: Vec<dbus::Path<'static>>,
}

pub trait NetConnmanClock {
    type Err;
    fn get_properties(&self) -> Result<::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>, Self::Err>;
    fn set_property(&self, name: &str, value: arg::Variant<Box<arg::RefArg>>) -> Result<(), Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> NetConnmanClock for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn get_properties(&self) -> Result<::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>, Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Clock".into(), &"GetProperties".into(), |_| {
        }));
        try!(m.as_result());
        let mut i = m.iter_init();
        let properties: ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>> = try!(i.read());
        Ok(properties)
    }

    fn set_property(&self, name: &str, value: arg::Variant<Box<arg::RefArg>>) -> Result<(), Self::Err> {
        let mut m = try!(self.method_call_with_args(&"net.connman.Clock".into(), &"SetProperty".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(name);
            i.append(value);
        }));
        try!(m.as_result());
        Ok(())
    }
}

pub fn net_connman_clock_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: NetConnmanClock<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("net.connman.Clock", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let properties = try!(d.get_properties());
        let rm = minfo.msg.method_return();
        let rm = rm.append1(properties);
        Ok(vec!(rm))
    };
    let m = factory.method("GetProperties", Default::default(), h);
    let m = m.out_arg(("properties", "a{sv}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = try!(i.read());
        let value: arg::Variant<Box<arg::RefArg>> = try!(i.read());
        let d = fclone(minfo);
        try!(d.set_property(name, value));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SetProperty", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("value", "v"));
    let i = i.add_m(m);
    i
}

#[derive(Debug)]
pub struct NetConnmanClockPropertyChanged {
    pub name: String,
    pub value: arg::Variant<Box<arg::RefArg>>,
}
